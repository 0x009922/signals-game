# Signals Game

Игра сигналами. Построение систем, в которых воспроизводимы логические элементы. Идея от редстоуна в майнкрафте.

## компоненты

### сетка

Сетка из квадратов, на которой будут располагаться элементы. Пока пусть так, для упрощения разработки и использования. В идеале, конечно же, сделать мощный редактор для протягивания связей между элементами, но это не сейчас.

### проводник

Проводниковый элемент. Может иметь заряд и не иметь, 0/1. Становится 1, если рядом есть источники питания, то есть в его клетку направлен какой-либо поток, заряд. Если, скажем, по соседству с ним есть активный проводник. Или какой-нибудь ещё элемент, который способен направлять в каком-то направлени заряд. Такие предметы принадлежат одному типажу? _Те, что способны отдавать заряд_.

### Источник питания

Название говорит само за себя. Как и проводник, может быть помещён в клетку. Состояние - вкл/выкл. Если включён, то отдаёт заряд своим соседям, во все стороны.

### Инвертор

Элемент, помещается в клетку. Имеет направление - север юг запад восток. Вернее, имеет тыл и фронт. С тыловой части вход, с передней выход. Инвертирует поступающий сигнал. Если на входе есть, на выходе нет. И наоборот.

### Лампочка

Элемент, который наглядно показывает наличие сигнала и только это, by design. По сути конечный элемент цепочек, но может быть и просто индикатором любым. Ставится в сетку, может иметь входы со всех сторон

---

В принципе из этого можно собрать и всё остальное. И, ИЛИ, ИЛИ-НЕ и так далее до процессора (ага).

Взаимосвязи между элементами должны быть отображены. То есть проводники должны быть связаны визуально, двойные, тройные, перекрёстки - всё как в майне. Также соединения с источниками питания и с инверторами.

> Для этого нужна какая-то над-система, работающая не с конкретными элементами, а с интерфейсами типа 'вот тут в сетке элемент и в эти клетки у него ноги расти могут'. А далее, когда какой-то элемент хочет себя отрисовать и смотрит, где он стыкуется, он стыкуется с теми элементами, у которых 'ноги растут' к нему.

## как бегают сигналы

Как? Проводник не может быть держателем сигнала, ведь так? В майнкрафте так. Его активность устанавливается другими элементами, удалённостью от них. А я бы хотел, чтобы было видно прямо как бегают сигналы по цепям.

Допустим, есть источник питания и от него проводок к лампочке. Источник питания врубается, и всем соседям сообщается о том, чтобы они становились активными.

```

  #---@


# - источник
*дефис* - провод
@ - лампочка
```

Сначала первый проводник загорается и говорит своим соседям загореться. Потом второй загорается и говорит остальным загореться. И так постепенно доходит до лампочки, она загорается.

Нет. Событиями это всё проводить - убиться об стену. Состояния - вот ключ к простоте. Скажем, надо хранить для каждой ячейки в сетке, какие откуда заряды поступают. Например, если в ячейке `0, 0` есть активный источник питания, то для соседа ячейки этой, например, `1, 0`, есть инфа о том, что сюда идёт заряд из `0, 0`. Когда активность перестанет быть, тогда этой инфы больше не будет.

Для чего я это думаю? Потому что непонятно, как быть со случаями, когда проводники сами могут начать выступать источниками. Если я выключаю источник, то провод должен потухнуть. Не должно быть такого, что провод состоит из двух частей, к одному концу которого подключён источник, после чего источник исчезает, а проводок продолжает питаться от другого конца, к которому ничего не подключено.

Ввести отдельно живущую сущность, 'заряд'? Заряды бегают по разным направлениями. Поступают из одного места, бегут в другие... тогда вообще всё может быть запутанно, если замыкать провода на себя.

Сделать всё же как в майне? Провода активны на расстоянии N-шагов от любого источника питания? Вводить буфферы?

Хочется наблюдать, как это всё волнообразно нарастает. Заряды не могут просто взять и побежать назад, как не может потечь в гору вода. Представлять, будто мои заряды - это вода? И как она будет растекаться по проводниками, инвертироваться и так далее? Вода, допустим, может течь только вниз.

**решение:** сделать всё же как в майне. Провод целиком либо имеет заряд, либо нет. Дальность от источников роли не играет. Провод - это совокупность соединённых проводников-соседей. Как только он становится активным, активными в тот же момент становятся и те элементы, которые он питает.

## UI

Клавиши управления видны всегда. Регулировка скорости сигналов. Клавиши управления меняются в зависимости от элемента, над которым располагаеся мышь.

Есть сетка, её можно передвигать и масштабировать колёсиком (зум не MVP). В клетки можно ставить различные элементы. Для каждого элемента своя кнопка создания. Если в клетке уже есть элемент, то при наведении соответствующие кнопки подсвечиваются.

**Сделать отзывчивым и приятным - одна из главнейших целей.**

-   Зажать кнопку и мышью ведя вся усеивать элементами одного типа, соответствующими нажатой кнопке.
-   Нельзя зажать одновременно несколько "создающих" кнопок. Вернее, зажать можно, но активна будет только первая из них
-   Также с кнопкой удаления. Её можно зажать и вести по всем клеткам, которые надо очистить

## Core

Ядро. Как там оно изнутри работает. Описание алгоритма и принципов работы, до мелочей.

В корне своём, есть некая сетка, на ней разные элементы. В зависимости от положения относительно друг друга они по-разному друг на друга влияют. Эта система работает **циклично**. В каждом цикле обновляется состояние активности.

### первая концепция

Помимо сетки элементов есть сетка активности, наложенная поверх на сетку с элементами. В каждой ячейке хранится информация о том...

Нет, сетка одна и она постоянна. А вот в каждой ячейке есть множество разной инфы. Первая - какой элемент там лежит. Пустой ли или что-то другое. Второе - информация о том, что с какой-то стороны туда поступает "сигнал". Грубо говоря, массив направлений.

**Направления**: север-юг-запад-восток. Хули ещё надо-то.

И вот, допустим, источник питания зажёгся и начинает транслировать сигнал по всем направлениям (ближайшим клеткам-соседям). В следующем цикле те элементы, которые оказались в тех клетках, в которые идёт теперь сигнал, получают инфу об этом и могут уже сами изменить своё поведение. Начать транслировать сигналы куда-то, или прекратить...

Как это сделать декларативно и производительно? Не так, чтобы в каждом цикле опрашивался каждый элемент и чтобы он отдавал своё состояние. Должна быть точечная реакция на изменения.

И ещё важная **проблема**: надо объединять множество соседствующих проводников в одно целое множество. И разъединять в случае, когда соединяющее звено удаляется. Мысли: при добавлении нового смотреть соседей. Если их нет, то у этого нового своё единичное множество. Если рядом есть, то присоединиться к нему. При добавлении относительно просто. А при удалении... Можно применить такой рекурсивный алгоритм. Взять множество, удалить из него удаляемый. Изъять из него первый попавшийся и взять его за начало. Взять второй - сосед... Не, не то. Может, достаточно просто хранить в проводе все соседний элементы для навигации быстрой к ним. А при подключении сигнала к какому-либо из проводов рекурсивно проходить ко всем остальным и фантомно им прописывать, мол, источник сигнала есть вон там-то и там-то. Когда где-то он отключится, он так же рекурсивно отключится и у всех соседних. Ага, тут понятно, а что при добавлении провода по такой схеме? Сначала он интегрируется к своим соседям и перенимает их сигнал, копирует. Или лучше не копирует? Один объект на всех? Ну в общем да, не суть. А если в него ещё откуда-то поступает сигнал, в его ячейку, напрямую, то он ещё и рекурсивно всем прописывает новый источник сигнала (если он есть) (рекурсия не нужна, если на всех один объект с данными об источниках). А вот при удалении... Сначала, если этот проводник является источников сигнала, то он должен себя удалить у остальных. Затем удаляет себя из соседей остальных. А если там проводники были объединены во множества, то они, возможно, должны разъединиться.

Ладно, оставим пока проводники. Энивей надо решать всё это красиво, декларативно. Оперировать данными, состояниями, а не объектами, поведением, которые как-то там они так нах работают непонятно как.

**Похоже, делать ядро в первую очередь я буду всё же на расте.**

### стараюсь определиться с поведением. Чёткое ТЗ.

На сетке могут располагаться четыре типа элементов - источник питания, проводник, инвертор, лампочка. Они работают с сигналами, как-то с ними взаимодействуют. Система из этих элеметнов работает циклично. В одном тике состояния активности могут измениться - могут появиться новые источники сигналов, могут исчезнуть. В следующем цикле происходит реакция на изменения в прошлом.

Источник питания может быть активен и не активен. Если активен, то посылает сигналы в соседние 4 клетки.

Проводник - проводит сигнал. Множество соседних проводников образуют единую группу. Когда сигнал поступает в любой из них, все они загораются и излучают сигнал в соседние клетки (но не в самих себя, разумеется).

Инвертор - инвертирует входящий сигнал в выходящий. Имеет чёткое направление, вход и выход. Если на входе есть сигнал, то на выходе его больше нет. Если на входе ничего - то на выходе сигнал есть.

Лампочка - принимает сигнал со всех направлений. Индикатор того, что в этой точке есть сигнал.

#### Каскад активации

В одном цикле, допустим, активируется источник. Он при этом сообщает о том, что надо активировать соседей. В следующем цикле они активируются.

В одном цикле активируется проводник. В этом же цикле "загорается" и вся остальная часть его соседей. И все они сообщают о том, что надо активировать их соседей. В следующем цикле соседи активируются.

В одном цикле проводник деактивируется. Если к остальным соседям ничего не подключено, то вся группа тухнет. В следующем цикле потухнет и то, что является к этим проводникам соседями.

В одном цикле загорается проводник. К нему подключена лампочка. В следующем цикле она тоже станет активной, то бишь загорится.

Есть инвертор и два проводника, на входе и на выходе. Ко входу ставится источник. Источник запускают. В первом цикле он просто горит. Далее загорается провод. Далее инвертор меняет полярность. Далее провод на выходе тухнет.

```
Источник слева, далее провод, далее лампочка. Включение источника.

0----.
1----.
1====.
1====*

Схема с инвертором. Выключение источника

1==!>0--.
0==!>0--.
0--!>0--.
0--!>1--.
0--!>1==.
0--!>1==*
```

**Цикличность.** Думаю, стоит сделать не один цикл обновления на всех разом, а более событийно, но, однако же, с фиксированным интервалом. Допустим, есть источник. Его отключают - он через какое-то время сообщает об этом остальным. Провод отключается - через какое-то время сообщает остальным. И так далее. В этом случае, правда, уже не так просто это делать будет на расте, скорее на js.

## Наброски

Надо пробовать описывать интерфейс того, как с этим работать извне. Может, станет понятно, как это элегантно реализовать внутренне. Или же стоит сначала реализовать хоть как-то?

```ts
interface Element {}

interface System {
    mountElement: (x: number, y: number, elem: Element) => void;
    removeElement: (x: number, y: number) => void;
}

const system = new System();
```

Элементы не должны знать, в какой точке они находятся. Всю инфу об окружении они получают извне. Как? "Окружение" предоставляет ему какие-то методы для извлечения информации?

```rs
enum Direction {
  Up,
  Down,
  Left,
  Right
}

struct SignalInfo {
  from: Direction
}

trait Environment {
  fn what_is_there(dx: i32, dy: i32) -> ;

  fn signals_at_my_place() -> &Vec<SignalInfo>;
}

struct EnergySource {};

impl EnergySource {
  fn update<T>(&mut self, env: &T) where T: Environment;
}
```

### Модель акторов?

Какие тут могут быть акторы?

-   Сетка с элементами
-   Каждый элемент - источник, провод, лампочка, инвертор etc

Сетка. Какое у неё состояние? Её элементы, знание об элементах.

Источник питания. Состояние - вкл выкл. Не принимает никакие сообщения, только отсылает на сетку, что он направляет туда-то и туда-то сигналы.

Проводок. Принимает сообщения о том, что где-то активно или неактивно. Передаёт соседям, что он их питает...

### Избавиться от проводов

Дабы упростить логику взаимодействия элементов между собой, можно внести одиночные элементы-проводники - буфферы. С возможностью делать так, чтобы они имели несколько направлений выхода. Ничего, если они начнут питать самих себя - это не критично и привносит элемент хаотичности и творчества.

### Плоскость - невозможность пересечения

Должна быть возможность пересекать провода между собой. Как это можно сделать? Добавить новый элемент - **мост**. Он бы действовал как буффер, только имел бы один выход и возможность устанавливать, на какое расстояние он перекидывает сигнал.

Вообще конечно надо бы расширять функциональность буффера для такого - чтобы он мог рассылать сигнал в какие угодно стороны и на какие угодно расстояния.

Но вообще с мостами пропадает надобность в том, чтобы выстраивать последовательные буфферы. Но с другой стороны, чего такого?

Понятное дело, что тут надо будет в UI подсвечивать клетки, куда исходит сигнал из элемента. Из любого.

### Элементы

-   Источник питания. Активные действия - вкл выкл. При наведении подсвечиваются клетки, которые он питает. Визуально можно сделать так: внутри колёсико, которое разгоняется и крутится, когда становится активным, и останавливается, когда становится неактивным.
-   Буффер. Имеет 4 порта со всех сторон, каждый из которых может быть как входом, так и выходом. Активные действия - переключение типов для каждого порта. Назначить для каждого четыре клавиши, которые бы переключали. 1-4, или какие-то буквы. Визаульно можно оформить как крестик в четыре стороны. Порты выходящие - кружочки, полые или залитые цветом (в зависимости от активности). Входящие порты просто палочки.
-   Инвертор. Один вход, с другой стороны выход. Может находиться в двух положениях - вертикально и горизонтально. Активные действия - только переключение положения кнопкой. Или колёсиком мыши.
-   Лампочка. Активных действий нет. Горит или не горит. Горит, если в эту клетку приходит какой-либо сигнал.

### Модель акторов во взаимодействии элементов между собой

Актор-доска получает сообщение - создать источник питания в такой-то точке.

Вообще, акторы здесь должны быть универсальны - их описание должно сводиться к описанию входящих сообщений, или просто описанию интерфейсов, типажей их, методов с аргументами. В дальнейшем они лишь будут перекидываться друг с другом сообщениями. Нужно ли делать между ними какую-то прослойку-фреймворк для организации взаимодействия? Возможно.

Акторы не должны быть видны снаружи - снаружи есть фасад с реактивным состоянием и методами.

А вот внутри там множество сущностей с состояниями, и взаимодействуют они через сообщения друг другу.

```ts
// actors-model.ts

type Actor<T> = {
    dispatch: () => void;
    // destructor: () => void;
};

interface SignalSourceActorMessage {
    power_on: null;
    power_off: null;
}

class SignalSourceActor implements Actor<SignalSourceActorMessage> {
    active: Ref<boolean>;

    constructor() {
        this.active = ref(false);

        watch(this.active, (val) => {
            dispatch();
        });
    }

    destructor() {
        // уничтожаю watcher-ы
    }

    power_on() {
        this.active.value = true;
    }

    power_off() {
        this.active.value = false;
    }
}
```

### Фасад...

```ts
class ElemSource {
    private active: Ref<boolean>;

    public readonly active:

    power_on() {

    }

    power_off() {

    }
}

enum ElemBufferPortState {
    In,
    Out
};

enum Direction {
    Up,
    Down,
    Left,
    Right
};

enum Orientation {
    Vertical,
    Horizontal
}

type ElemBufferPorts = {
    [K in Direction]: ElemBufferPortState
}

class ElemBuffer {
    // reactive
    ports: ElemBufferPorts;

    toggle_port_state(dir: Direction) {

    }

    set_port_state(dir: Direction, state: ElemBufferPortState) {

    }
}

class ElemInvertor {
    orientation: Ref<Orientation>;

    set_orientation(val: Orientation) {

    }
}

class ElemLightBulb {
    // ???
}

type Element = ???;

interface SignalsBoard {
    net: Map<string, ???>;

    put_element: (x: number, y: number, el: ???) => void;
    remove_element: (x: number, y: number) => void;
}
```

Всем элементам надо передавать какой-то контекст, через который они будут взаимодействовать. Типа...

```ts
interface EmittedSignal {
    dir: Direction;
    step?: number; // по умолчанию 1, должно быть положительное число (иначе ошибка)
    // dy: number;
}

interface ReceivedSignal {
    from: Direction;
}

interface Context {
    /**
     * Устанавливает, какое у сигнала излучение, то есть куда и насколько он излучает сигнал
     */
    set_self_emitting: (signals: EmittedSignal[]) => void;
    // Или лучше реактивный массив, который можно менять?
    emitted_signals: EmittedSignal[];
    emitted_signals: Ref<EmittedSignal[]>;

    // Реактивный массив входящих в элемент сигналов - только для чтения, разумеется.
    readonly received_signals: ReceivedSignal[];
    readonly received_signals: Ref<ReceivedSignal[]>;
}
```

Что ещё нужно для контекста взаимодействия между элементами? Они ничего друг о друге не знают, а сообщают окружению лишь то, что они излучают, и получают от него только то, что в них приходит.

Значит, элемент доски должен реализовывать такой интерфейс?

```ts
interface SignalElement {
    use_context: (ctx: Context) => void;
    // хук уничтожения
    unmounted: () => void;
}
```

А контекст, изнутри - это некий класс, который знает об элементе то, где он находится, и вообще знает, как уже с другими элементами работать.

Кто создаёт контекст? Некий глобальный актор. Он может получать элементы с мета-информацией о них, задавать для них контексты и следить за тем, чтобы контексты синхронизировались между собой. Скажем, один элемент в такой-то точке начал излучать - значит, мастер контекстов это подхватывает, ставит таймер и обновляет контексты других элементов в зависимости от того, что куда излучает и куда попадает. Бинго.

```ts
class ContextImpl implements Context {
    public emitted_signals: Ref<EmittedSignal[]>;

    public readonly received_signals: // computed от приватного received

    private received: Ref<ReceivedSignal[]>;

    position: Vector2;

    constructor() {
        // инициализация позиций и массивов
        // возможно приём начальных данных о приёмных сигналах
    }

    update_received(data: ReceivedSignal[]) {
        // обновление данных внутри, здесь можно поставить таймер.
        // или где нужно ставить таймер?
    }
}
```

И какой он, композитор контекстов сигналов?

```ts
interface CellData {
    elem: SignalElement | null;
    elem_ctx: ContextImpl | null;
    // Вместо привязки к ContextImpl создать отдельный интерфейс для того, как контекст смотрится со стороны композитора?
    signals_emitted: SignalAddresses[];
    signals_received: SignalAddresses[];
}

interface PosToStr {
    pos_to_str: () => string;
    readonly x: number;
    readonly y: number;
}

class Compositor<P extends PosToStr> {
    /**
     * Единая хэш-карта с инфой о поле (не реактивная)
     * - какой элемент есть в клетке
     * - контекст элемента - через который можно ему менять принимаемые данные
     * - полученные сигналы, откуда
     * - принятые сигналы, откуда
     */
    private cells: Map<string, CellData>;

    mount(pos: PosToStr, elem: SignalElement) {
        // монтирует у себя элемент, создаёт ему контекст
    }

    unmount(pos: PosToStr) {
        // демонтирует у себя элемент, обновляет связанные контексты
    }

    // private signals: Map<string, Received>
}

interface SignalAddresses {
    from: string;
    to: string;
}
```

По сути это всё, что делает композитор. Его там вообще не ебёт, как себя внутри ведут элементы. Они обновляют у себя внутри контекст, композитор это отлавливает, обновляет связанные

### Но вернёмся к фасаду...

Это в итоге будет одна большая карта - реактивная, с множеством элементов.

```ts
interface Facade<T extends SignalElement> {
    /**
     * shallowReactive(new Map())
     *
     * Шаллоу, чтобы не перегружать систему реактивности. Внутренние объекты и так будут реактивными, если надо.
     */
    readonly elems: Map<string, T>;

    mount(el: T, pos: Pos);

    unmount(pos: Pos);
}

// enum Elems {
//   Source,
//   Buffer,
//   Bridge,
//   Invert,
//   Diode
// }

// interface Elem extends SignalElement,
```

Похоже, в фасаде ничего и не нужно в общем-то?

### Пробую реализовать источник питания

```ts
class SignalSource implements SignalElement {
    private _active: Ref<boolean>;

    public readonly active: ComputedRef<boolean>;

    constructor() {
        this._active = ref(false);
        this.active = computed(() => this._active.value);
    }

    use_context(ctx) {
        // настраиваю работу с контекстом
    }

    unmounted() {
        // уничтожаю созданные вотчеры
        // можно для этого создать утилиту-линкера, который будет автоматом запоминать все
        // stop-ы и разом сможет их инвокать
    }
}
```
